// Tests/SwiftProtobufTests/Test_NameMap.swift - Tests for public NameMap API
//
// Copyright (c) 2014 - 2023 Apple Inc. and the project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See LICENSE.txt for license information:
// https://github.com/apple/swift-protobuf/blob/main/LICENSE.txt
//
// -----------------------------------------------------------------------------

import XCTest
import SwiftProtobuf

final class Test_NameMap: XCTestCase {

    // MARK: - Test Data Setup
    
    private var testNameMap: NameMap {
        let internalMap: _NameMap = [
            1: _NameMap.NameDescription.same(proto: "field_one"),
            2: _NameMap.NameDescription.standard(proto: "field_two"),
            3: _NameMap.NameDescription.unique(proto: "field_three", json: "fieldThree"),
            5: _NameMap.NameDescription.aliased(proto: "enum_value", aliases: ["ENUM_VALUE_ALIAS"])
        ]
        return NameMap(internalMap)
    }
    
    private var emptyNameMap: NameMap {
        return NameMap()
    }

    // MARK: - Basic Initialization Tests

    func testInitialization() {
        // Test empty initialization
        let empty = NameMap()
        XCTAssertTrue(empty.isEmpty)
        
        // Test wrapping internal map
        let wrapped = testNameMap
        XCTAssertFalse(wrapped.isEmpty)
        
        // Test bytecode initialization (skip for now due to empty bytecode parsing issue)
        // Note: Empty bytecode causes parsing errors, so we'll skip this test
        // In real usage, bytecode would be generated by the compiler and never be empty
        
        // Test explicit initialization
        let explicit = NameMap(
            reservedNames: [],
            reservedRanges: [],
            numberNameMappings: [
                1: _NameMap.NameDescription.same(proto: "test_field")
            ]
        )
        XCTAssertFalse(explicit.isEmpty)
    }

    // MARK: - FieldNameInfo Tests

    func testFieldNameInfo() {
        let info = FieldNameInfo(protoName: "test_field", jsonName: "testField", number: 1)
        
        XCTAssertEqual(info.protoName, "test_field")
        XCTAssertEqual(info.jsonName, "testField")
        XCTAssertEqual(info.number, 1)
        
        // Test equality
        let info2 = FieldNameInfo(protoName: "test_field", jsonName: "testField", number: 1)
        XCTAssertEqual(info, info2)
        
        // Test inequality
        let info3 = FieldNameInfo(protoName: "other_field", jsonName: "testField", number: 1)
        XCTAssertNotEqual(info, info3)
        
        // Test description
        let expectedDescription = "FieldNameInfo(number: 1, proto: \"test_field\", json: \"testField\")"
        XCTAssertEqual(info.description, expectedDescription)
        
        // Test hashing
        let hashable: Set<FieldNameInfo> = [info, info2, info3]
        XCTAssertEqual(hashable.count, 2) // info and info2 should be equal
    }

    // MARK: - Name Lookup Tests

    func testNameLookup() {
        let nameMap = testNameMap
        
        // Test nameInfo lookup
        let info1 = nameMap.nameInfo(for: 1)
        XCTAssertNotNil(info1)
        XCTAssertEqual(info1?.protoName, "field_one")
        XCTAssertEqual(info1?.jsonName, "field_one") // Same as proto for .same case
        XCTAssertEqual(info1?.number, 1)
        
        // Test non-existent field
        let infoNil = nameMap.nameInfo(for: 999)
        XCTAssertNil(infoNil)
        
        // Test protoName lookup
        let protoName2 = nameMap.protoName(for: 2)
        XCTAssertEqual(protoName2, "field_two")
        
        // Test jsonName lookup
        let jsonName2 = nameMap.jsonName(for: 2)
        XCTAssertEqual(jsonName2, "fieldTwo") // Should be converted from field_two
        
        // Test unique names
        let info3 = nameMap.nameInfo(for: 3)
        XCTAssertNotNil(info3)
        XCTAssertEqual(info3?.protoName, "field_three")
        XCTAssertEqual(info3?.jsonName, "fieldThree")
    }

    // MARK: - Number Lookup Tests

    func testNumberLookup() {
        let nameMap = testNameMap
        
        // Test proto name lookup
        let number1 = nameMap.number(forProtoName: "field_one")
        XCTAssertEqual(number1, 1)
        
        // Test JSON name lookup
        let number2 = nameMap.number(forJSONName: "fieldTwo")
        XCTAssertEqual(number2, 2)
        
        // Test non-existent name
        let numberNil = nameMap.number(forProtoName: "non_existent")
        XCTAssertNil(numberNil)
        
        // Test that JSON lookup also finds proto names (per protobuf spec)
        let number1Json = nameMap.number(forJSONName: "field_one")
        XCTAssertEqual(number1Json, 1)
        
        // Test aliases
        let aliasNumber = nameMap.number(forProtoName: "ENUM_VALUE_ALIAS")
        XCTAssertEqual(aliasNumber, 5)
    }

    // MARK: - Collection Access Tests

    func testCollectionAccess() {
        let nameMap = testNameMap
        
        // Test allFieldNames
        let allFields = nameMap.allFieldNames
        XCTAssertGreaterThan(allFields.count, 0)
        
        // Verify fields are sorted by number
        for i in 1..<allFields.count {
            XCTAssertLessThan(allFields[i-1].number, allFields[i].number)
        }
        
        // Test allNumbers
        let allNumbers = nameMap.allNumbers
        XCTAssertEqual(allNumbers, allFields.map(\.number))
        
        // Test allProtoNames
        let allProtoNames = nameMap.allProtoNames
        XCTAssertGreaterThan(allProtoNames.count, 0)
        
        // Verify proto names are sorted alphabetically
        let sortedProtoNames = allProtoNames.sorted()
        XCTAssertEqual(allProtoNames, sortedProtoNames)
    }

    // MARK: - Reserved Name/Number Tests

    func testReservedChecking() {
        let nameMap = testNameMap
        
        // Test reserved name checking (should work even if we can't access the private data)
        let isReserved = nameMap.isReservedName("some_name")
        XCTAssertFalse(isReserved) // Should be false for our test data
        
        // Test reserved number checking
        let isReservedNumber = nameMap.isReservedNumber(1000)
        XCTAssertFalse(isReservedNumber) // Should be false for our test data
        
        // Test Int32 overload
        let isReservedInt32 = nameMap.isReservedNumber(Int32(1000))
        XCTAssertFalse(isReservedInt32)
        
        // Test reserved names/ranges properties
        let reservedNames = nameMap.reservedNames
        let reservedRanges = nameMap.reservedRanges
        
        // These should be empty due to our implementation limitations
        XCTAssertTrue(reservedNames.isEmpty)
        XCTAssertTrue(reservedRanges.isEmpty)
    }

    // MARK: - Convenience Method Tests

    func testConvenienceMethods() {
        let nameMap = testNameMap
        let emptyMap = emptyNameMap
        
        // Test hasMapping
        XCTAssertTrue(nameMap.hasMapping(for: 1))
        XCTAssertFalse(nameMap.hasMapping(for: 999))
        
        XCTAssertTrue(nameMap.hasMapping(forProtoName: "field_one"))
        XCTAssertFalse(nameMap.hasMapping(forProtoName: "non_existent"))
        
        XCTAssertTrue(nameMap.hasMapping(forJSONName: "fieldTwo"))
        XCTAssertFalse(nameMap.hasMapping(forJSONName: "nonExistent"))
        
        // Test isEmpty
        XCTAssertFalse(nameMap.isEmpty)
        XCTAssertTrue(emptyMap.isEmpty)
        
        // Test count
        XCTAssertGreaterThan(nameMap.count, 0)
        XCTAssertEqual(emptyMap.count, 0)
        
        // Verify count consistency
        XCTAssertEqual(nameMap.count, nameMap.allFieldNames.count)
    }

    // MARK: - CustomStringConvertible Tests

    func testStringDescription() {
        let nameMap = testNameMap
        let description = nameMap.description
        
        XCTAssertTrue(description.hasPrefix("NameMap(["))
        XCTAssertTrue(description.hasSuffix("])"))
        
        // Should contain field information
        XCTAssertTrue(description.contains("field_one"))
        
        // Empty map description
        let emptyDescription = emptyNameMap.description
        XCTAssertEqual(emptyDescription, "NameMap([])")
    }

    // MARK: - Thread Safety Tests

    func testThreadSafety() {
        let nameMap = testNameMap
        let expectation = XCTestExpectation(description: "Thread safety test")
        expectation.expectedFulfillmentCount = 10
        
        // Test concurrent access from multiple threads
        for _ in 0..<10 {
            DispatchQueue.global().async {
                // Perform various operations concurrently
                let _ = nameMap.nameInfo(for: 1)
                let _ = nameMap.number(forProtoName: "field_one")
                let _ = nameMap.allFieldNames
                let _ = nameMap.count
                let _ = nameMap.isEmpty
                
                expectation.fulfill()
            }
        }
        
        wait(for: [expectation], timeout: 5.0)
    }

    // MARK: - Performance Tests

    func testPerformance() {
        let nameMap = testNameMap
        
        // Test lookup performance
        measure {
            for i in 1...1000 {
                let _ = nameMap.nameInfo(for: i % 10 + 1)
            }
        }
    }

    // MARK: - Edge Cases

    func testEdgeCases() {
        let nameMap = testNameMap
        
        // Test with field number 0 (should not exist)
        XCTAssertNil(nameMap.nameInfo(for: 0))
        
        // Test with negative field number
        XCTAssertNil(nameMap.nameInfo(for: -1))
        
        // Test with very large field number
        XCTAssertNil(nameMap.nameInfo(for: Int.max))
        
        // Test with empty strings
        XCTAssertNil(nameMap.number(forProtoName: ""))
        XCTAssertNil(nameMap.number(forJSONName: ""))
        
        // Test reserved checking with empty strings
        XCTAssertFalse(nameMap.isReservedName(""))
    }

    // MARK: - Type-Safe Enum Tests

    enum TestEnum: Int, CaseIterable {
        case first = 1
        case second = 2  
        case third = 3
        case fourth = 5  // Note: intentionally skipping 4 to test sparse mapping
    }
    
    enum AnotherEnum: Int, CaseIterable {
        case alpha = 10
        case beta = 20
    }

    func testEnumNameLookup() {
        let nameMap = testNameMap
        
        // Test nameInfo with enum case
        let info1 = nameMap.nameInfo(for: TestEnum.first)
        XCTAssertNotNil(info1)
        XCTAssertEqual(info1?.number, 1)
        XCTAssertEqual(info1?.protoName, "field_one")
        
        // Test protoName with enum case
        let protoName2 = nameMap.protoName(for: TestEnum.second)
        XCTAssertEqual(protoName2, "field_two")
        
        // Test jsonName with enum case
        let jsonName2 = nameMap.jsonName(for: TestEnum.second)
        XCTAssertEqual(jsonName2, "fieldTwo")
        
        // Test with mapped enum case (third maps to our field 3)
        let info3 = nameMap.nameInfo(for: TestEnum.third)
        XCTAssertNotNil(info3)
        XCTAssertEqual(info3?.protoName, "field_three")
        XCTAssertEqual(info3?.jsonName, "fieldThree")
        
        // Test with mapped enum case (fourth maps to our field 5 - enum_value)
        let info5 = nameMap.nameInfo(for: TestEnum.fourth)
        XCTAssertNotNil(info5)
        XCTAssertEqual(info5?.protoName, "enum_value")
        
        // Test with enum case that doesn't have mapping
        let nameMapWithoutMapping = emptyNameMap
        let nilInfo = nameMapWithoutMapping.nameInfo(for: TestEnum.first)
        XCTAssertNil(nilInfo)
    }

    func testEnumCaseLookup() {
        let nameMap = testNameMap
        
        // Test enumCase lookup by proto name
        let enumCase1: TestEnum? = nameMap.enumCase(forProtoName: "field_one")
        XCTAssertEqual(enumCase1, .first)
        
        // Test enumCase lookup by JSON name
        let enumCase2: TestEnum? = nameMap.enumCase(forJSONName: "fieldTwo")
        XCTAssertEqual(enumCase2, .second)
        
        // Test enumCase lookup with explicit type parameter
        let enumCase3 = nameMap.enumCase(forProtoName: "field_three", as: TestEnum.self)
        XCTAssertEqual(enumCase3, .third)
        
        // Test enumCase lookup for aliased value
        let enumCase5: TestEnum? = nameMap.enumCase(forProtoName: "ENUM_VALUE_ALIAS")
        XCTAssertEqual(enumCase5, .fourth)
        
        // Test non-existent name
        let nilCase: TestEnum? = nameMap.enumCase(forProtoName: "non_existent")
        XCTAssertNil(nilCase)
        
        // Test with name that maps to number that's not a valid enum case
        // (This would happen if the name map has a number that's not in our test enum)
        let nameMapWith999 = NameMap(
            numberNameMappings: [
                999: _NameMap.NameDescription.same(proto: "unknown_field")
            ]
        )
        let nilCase999: TestEnum? = nameMapWith999.enumCase(forProtoName: "unknown_field")
        XCTAssertNil(nilCase999)
    }

    func testEnumConvenienceMethods() {
        let nameMap = testNameMap
        
        // Test hasMapping with enum case
        XCTAssertTrue(nameMap.hasMapping(for: TestEnum.first))
        XCTAssertTrue(nameMap.hasMapping(for: TestEnum.second))
        XCTAssertTrue(nameMap.hasMapping(for: TestEnum.third))
        XCTAssertTrue(nameMap.hasMapping(for: TestEnum.fourth))
        
        // Test with enum case that doesn't exist in map
        let anotherEnumCase = AnotherEnum.alpha  // rawValue = 10, not in our test map
        XCTAssertFalse(nameMap.hasMapping(for: anotherEnumCase))
        
        // Test isReservedNumber with enum case
        XCTAssertFalse(nameMap.isReservedNumber(TestEnum.first))
        XCTAssertFalse(nameMap.isReservedNumber(TestEnum.second))
    }

    func testEnumCollectionMethods() {
        let nameMap = testNameMap
        
        // Test allFieldNames for specific enum type
        let testEnumFields = nameMap.allFieldNames(for: TestEnum.self)
        
        // Should include all TestEnum cases that have mappings
        let expectedNumbers = [1, 2, 3, 5] // corresponding to our TestEnum cases
        let actualNumbers = testEnumFields.map(\.number).sorted()
        XCTAssertEqual(actualNumbers, expectedNumbers)
        
        // Verify the field info is correct
        let field1 = testEnumFields.first { $0.number == 1 }
        XCTAssertEqual(field1?.protoName, "field_one")
        
        // Test allEnumCases for specific enum type
        let mappedCases = nameMap.allEnumCases(for: TestEnum.self)
        
        // Should include all TestEnum cases that exist in the map
        let expectedCases: [TestEnum] = [.first, .second, .third, .fourth]
        XCTAssertEqual(mappedCases, expectedCases)
        
        // Test with enum type that has no mappings
        let unmappedCases = nameMap.allEnumCases(for: AnotherEnum.self)
        XCTAssertTrue(unmappedCases.isEmpty)
        
        // Test allFieldNames with empty map
        let emptyEnumFields = emptyNameMap.allFieldNames(for: TestEnum.self)
        XCTAssertTrue(emptyEnumFields.isEmpty)
    }

    func testEnumTypeInference() {
        let nameMap = testNameMap
        
        // Test that Swift can infer the enum type from context
        let inferredCase1: TestEnum? = nameMap.enumCase(forProtoName: "field_one")
        XCTAssertEqual(inferredCase1, .first)
        
        let inferredCase2: TestEnum? = nameMap.enumCase(forJSONName: "fieldTwo")
        XCTAssertEqual(inferredCase2, .second)
        
        // Test explicit type specification when needed
        func processEnum<T: RawRepresentable>(_ enumCase: T) where T.RawValue == Int {
            let info = nameMap.nameInfo(for: enumCase)
            XCTAssertNotNil(info)
        }
        
        processEnum(TestEnum.first)
    }

    func testEnumWithSwiftProtobufEnum() {
        // Test with an actual SwiftProtobuf enum type
        let nameMapForType = NameMap(
            numberNameMappings: [
                0: _NameMap.NameDescription.same(proto: "TYPE_UNKNOWN"),
                1: _NameMap.NameDescription.same(proto: "TYPE_DOUBLE"),
                9: _NameMap.NameDescription.same(proto: "TYPE_STRING")
            ]
        )
        
        // Test lookup with SwiftProtobuf enum
        let typeUnknown = nameMapForType.nameInfo(for: Google_Protobuf_Field.Kind.typeUnknown)
        XCTAssertNotNil(typeUnknown)
        XCTAssertEqual(typeUnknown?.protoName, "TYPE_UNKNOWN")
        
        let typeString = nameMapForType.nameInfo(for: Google_Protobuf_Field.Kind.typeString)
        XCTAssertNotNil(typeString)
        XCTAssertEqual(typeString?.protoName, "TYPE_STRING")
        
        // Test reverse lookup
        let enumCase: Google_Protobuf_Field.Kind? = nameMapForType.enumCase(forProtoName: "TYPE_DOUBLE")
        XCTAssertEqual(enumCase, .typeDouble)
        
        // Test collection methods - only check the specific cases we mapped
        let allTypeCases = nameMapForType.allEnumCases(for: Google_Protobuf_Field.Kind.self)
        XCTAssertGreaterThanOrEqual(allTypeCases.count, 3) // At least the 3 we mapped
        XCTAssertTrue(allTypeCases.contains(.typeUnknown))
        XCTAssertTrue(allTypeCases.contains(.typeDouble))
        XCTAssertTrue(allTypeCases.contains(.typeString))
        
        // Test allFieldNames for the specific mapped cases
        let allTypeFields = nameMapForType.allFieldNames(for: Google_Protobuf_Field.Kind.self)
        let mappedNumbers = allTypeFields.map(\.number).sorted()
        XCTAssertTrue(mappedNumbers.contains(0))
        XCTAssertTrue(mappedNumbers.contains(1))
        XCTAssertTrue(mappedNumbers.contains(9))
    }

    func testEnumEdgeCases() {
        let nameMap = testNameMap
        
        // Test enum case with rawValue that doesn't exist in map
        enum UnmappedEnum: Int {
            case missing = 999
        }
        
        let missingInfo = nameMap.nameInfo(for: UnmappedEnum.missing)
        XCTAssertNil(missingInfo)
        
        XCTAssertFalse(nameMap.hasMapping(for: UnmappedEnum.missing))
        
        let missingProtoName = nameMap.protoName(for: UnmappedEnum.missing)
        XCTAssertNil(missingProtoName)
        
        let missingJSONName = nameMap.jsonName(for: UnmappedEnum.missing)
        XCTAssertNil(missingJSONName)
        
        // Test enum case lookup that would result in invalid enum case
        let nameMapWithInvalidNumber = NameMap(
            numberNameMappings: [
                999: _NameMap.NameDescription.same(proto: "invalid_case")
            ]
        )
        
        let invalidCase: TestEnum? = nameMapWithInvalidNumber.enumCase(forProtoName: "invalid_case")
        XCTAssertNil(invalidCase) // Should be nil because TestEnum doesn't have rawValue 999
    }

    // MARK: - Integration Tests

    func testIntegrationWithGeneratedCode() {
        // Test that the public API works with actual generated code structures
        let internalMap: _NameMap = [
            1: _NameMap.NameDescription.standard(proto: "user_id"),
            2: _NameMap.NameDescription.unique(proto: "full_name", json: "fullName"),
            3: _NameMap.NameDescription.same(proto: "email")
        ]
        
        let publicMap = NameMap(internalMap)
        
        // Verify all expected mappings exist
        XCTAssertEqual(publicMap.protoName(for: 1), "user_id")
        XCTAssertEqual(publicMap.jsonName(for: 1), "userId")
        
        XCTAssertEqual(publicMap.protoName(for: 2), "full_name")
        XCTAssertEqual(publicMap.jsonName(for: 2), "fullName")
        
        XCTAssertEqual(publicMap.protoName(for: 3), "email")
        XCTAssertEqual(publicMap.jsonName(for: 3), "email")
        
        // Test reverse lookups
        XCTAssertEqual(publicMap.number(forProtoName: "user_id"), 1)
        XCTAssertEqual(publicMap.number(forJSONName: "userId"), 1)
        XCTAssertEqual(publicMap.number(forJSONName: "user_id"), 1) // Should also work per spec
        
        XCTAssertEqual(publicMap.number(forProtoName: "full_name"), 2)
        XCTAssertEqual(publicMap.number(forJSONName: "fullName"), 2)
        
        XCTAssertEqual(publicMap.number(forProtoName: "email"), 3)
        XCTAssertEqual(publicMap.number(forJSONName: "email"), 3)
    }
} 